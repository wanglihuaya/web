<!DOCTYPE html>
<html lang="zh-CN">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<meta http-equiv="X-UA-Compatible" content="ie=edge" />
		<link rel="stylesheet" href="" />
		<title>对象冒充继承</title>
		<style></style>
	</head>

	<body>
		<script>
			//被继承的构造函数
			function Fn(name, age, gender) {
				this.name = name;
				this.age = age;
				this.gender = gender;
			}
			//一个空的构造函数Fn1
			function Fn1(name1, age1, gender1) {
				//让Fn将自己的属性，绑定为Fn1的子对象
				Fn.call(this, name1, age1, gender1);
				//我们将Fn的this -> Fn1的this -> Fn1创建的对象(obj)
			}
			//想要让Fn1创建的子对象 继承到Fn中的属性
			var obj = new Fn1("lihua","22","man");
			//obj中应该有 name age gender
      console.log(obj);
      /* Fn1
          age: "22"
          gender: "man"
          name: "lihua" 
          __proto__: Object*/
		</script>
	</body>
</html>
